# It parsec YAML BNF

%{
open Kmb_input
open Yamlspec_types
open Kmb_grammar

let na = 0 (* shoild fail *)
%}

grammar         <- spacing definition+ spacing  endOfFile

definition      <- number func_decl defined_as expressionFun
                   { fun (m, (n, expr)) -> (m, ParametrizedRule (n, expr)) }
                 / number name defined_as expression
                   { fun (m, (n, expr)) -> (m, Rule (n, expr)) }

case_expr       <- name l_EQ ( name { fun n -> if n.[0] = 'b' then 
                             / element { fun (n, el) -> Cmp (n, el) }
                             )

case            <- (case_expr spacing
                   / primary spacing { fun p -> Peg p }
                   / { fun () -> Peg Epsilon })
                    l_ARROW (case_expr / expression { fun e -> Peg e }) spacing

expressionFun  <- case_match+       { fun cs -> Match cs }
                / case_indicator+   { fun cs -> Indicator cs }
                / expression        { fun e -> Peg e }

expression      <- sequence (l_PIPE sequence)*   { make_alternates }

sequence        <- element*             { fun s -> make_sequence (s, None) }

element         <- name " * " var spacing 
                   { fun (s, t) -> 
                       Function ("repeat", [Value ("bool", "true");
                                            Ident t;
                                            Ident s]) }
                 / name " *< " var spacing
                   { fun (s, t) -> 
                        Function ("repeat",  [Value ("bool", "false");
                                              Func ("pred", [Ident t]);
                                              Ident s]) }

                 / name " *=< " var spacing
                   { fun (s, t) -> 
                       Function ("repeat", [Value ("bool", "false");
                                            Ident  t;
                                            Ident s]) }

                 /  name " * " digits spacing 
                   { fun (s, t) -> Function ("repeat", [Value ("bool", "true");
                                                        Value ("int", t);
                                                        Ident s]) }
                 / rejection
                 / primary (l_STAR               { fun () v -> Star v }
                           / l_PLUS              { fun () v -> Plus v }
                           / l_QUESTION          { fun () v -> Opt v }
                           )? spacing
                   { fun (el, repeat) -> 
                       match repeat with None -> el | Some f -> f el }

rejection       <- primary (" - " primary)+ spacing   { make_reject }

primary         <- func { fun (name, ps) -> Function (name, ps) }
                 / name !l_EQ { fun n -> Name n }
                 / l_OPEN expression l_CLOSE
                 / l_literal
                 / l_class 

# Lex

space           <- " "
number          <- space* '[' < [0-9a-z]+ > ']' space*
identifier      <- < [a-zA-Z0-9] [a-zA-Z0-9\-+]* > 
name            <- identifier { fun v -> v.lexeme }

func_decl       <- name l_OPEN name (l_COMMA name)* l_CLOSE
                   { fun (n, (p, ps)) -> (n, p :: ps) }
func            <- name l_OPEN params? l_CLOSE
                   { fun (n, ps) -> match ps with None -> (n, [])
                                                | Some ps -> (n, ps) }
param           <- func  { fun (n, ps) -> Func (n, ps) }
                 / name { fun n -> Ident n}
                 / digits { fun ds -> Value ("int", ds) }
params          <- param (l_COMMA param)* { fun (v, vs) -> v :: vs }

var             <- < [a-z] > { fun v -> v.lexeme }

l_COMMA           <- "," spacing
defined_as      <- space* "::=" spacing

l_literal         <- ('"""' { fun () -> [Char.code '\"'] }
                 / '"\"' { fun () -> [Char.code '\\'] }
                 / ["] (!["] l_char)* ["]
                 / ['] (!['] l_char)* [']
                 / l_hex { fun c -> [c]} )
                  { fun ls -> Literal ls }
l_class         <- "["  (!"]" range)* "]"      { fun cs -> Class cs }
range           <- l_hex '-' l_hex             { fun (c1, c2) -> Range (c1, c2) }
l_hex           <- '#x' < [0-9a-fA-F]+ >       { make_hex_char }
l_char          <- < . >                       { make_char }

l_QUESTION        <- '?' spacing
l_PLUS            <- '+' spacing
l_STAR            <- '*' spacing
l_PIPE            <- '|' spacing
l_OPEN            <- '(' spacing
l_CLOSE           <- ')'

newLine         <- [\r]? [\n]
comment         <- "/*" (!"*/" .)* "*/"
spacing         <- (comment / space / newLine)*
endOfFile       <- !.
digits           <- < '-'? [0-9]+ > { fun ds -> ds.lexeme }
l_EQ            <- " = "
l_ARROW        <- "=> "
value          <- < [a-zA-z] [a-zA-Z\-]* > { fun v -> v.lexeme }
