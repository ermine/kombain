# RFC 5234  ABNF January 2008

# Operator precedence

# Rule name, prose_val, Terminal value
# Comment
# Value range
# Repetition
# Grouping, Optional
# Concatenation
# Alternative
###

%{
open Kmb_lib
open Abnf_lib
%}


rulelist      <- ( rule (c_wsp / c_nl)* )+

rule          <- rulename defined_as elements c_nl
                 # continues if next line starts
                 #  with white space

rulename      <- < ALPHA (ALPHA / DIGIT / "-")* >

defined_as    <- c_wsp* ( "="   { fun () -> Define }
                        / "=/" { fun () -> IncrAlt }
                        ) c_wsp*
                 # basic rules definition and incremental alternatives

elements      <- alternation c_wsp*

c_wsp         <- WSP / (c_nl WSP)

c_nl          <- comment / CRLF / LF
                 # comment or newline

comment       <- ";" (WSP / VCHAR)* CRLF

alternation   <- concatenation (c_wsp* "/" c_wsp* concatenation)*
                 { fun (c1, cs) -> Alternation (c1, cs) }

concatenation <- repetition (c_wsp+ repetition)*
                 { fun (r1, r2) -> Concatenation (r1, r2) }

repetition    <- repeat? element
                 { fun (r, e) -> match r with None -> e | Some r -> Repeat (r,e)}

repeat        <- DIGITS { fun d -> CountRepeat d }
               / < DIGIT* > "*" < DIGIT* >
               { fun (d1, d2) ->
                   let d1 = 
                     if d1.lexeme = "" then None
                     else Some (int_of_string d1.lexeme) in
                   let d2 = 
                     if d2.lexeme = "" then None
                     else Some (int_of_string d2.lexeme) in
                     RangeRepeat (d1, d2)
               }

element       <- rulename   { fun r -> Name r.lexeme }
               / group / option / char_val / num_val / prose_val

group         <- "(" c_wsp* alternation c_wsp* ")"

option        <- "[" c_wsp* alternation c_wsp* "]"
                 { fun a -> Option a }

char_val      <- DQUOTE < ([\x20-\x21] / [\x23-\x7E])* > DQUOTE
                 # quoted string of SP and VCHAR without DQUOTE
                 { fun str -> Literal str.lexeme }

num_val       <- "%" (bin_val / dec_val / hex_val)

bin_val       <- "b" ( BITS "-"  BITS { fun (b1, b2) -> Class [Range (b1, b2)] }
                     / BITS ( "." BITS)* 
                       {fun (b1, bs) -> 
                            Class (List.map (fun c -> Char c) (b1 :: bs))}
                     )
                 # series of concatenated bit values or single ONEOF range

dec_val       <- "d" (DIGITS "-" DIGITS 
                      { fun (d1, d2) -> Class [Range (d1, d2)] }
                     / DIGITS ("." DIGITS)*   
                       { fun (d1, ds) -> 
                             Class (List.map (fun c -> Char c) (d1::ds)) }
                     )


hex_val       <- "x" (HEXDIGS "-" HEXDIGS     
                      { fun (h1, h2) -> Class [Range (h1, h2)] }
                     / HEXDIGS ("." HEXDIGS)*  
                       { fun (h1, hs) -> 
                             Class (List.map (fun c -> Char c) (h1::hs)) }
                     )

prose_val     <- "<" < ([\x20-\x3D] / [\x3F-\x7E])* > ">"
                 # bracketed string of SP and VCHAR without angles
                 # prose description, to be used as last resort
                 { fun p -> Prose p }


# Core Rules

ALPHA         <- [\x41-\x5A] / [\x61-\x7A]   
                 # A-Z / a-z

BITS          <- < BIT+ > { fun bs -> int_of_string ("0b" ^ bs.lexeme) }
BIT           <- "0" / "1"

CHAR          <- [\x01-\x7F]
                 # any 7-bit US-ASCII character, excluding NUL

CR            <- [\x0D]
                 # carriage return

CRLF          <- CR LF
                 # Internet standard newline

CTL           <- [\x00-\x1F] / [\x7F]
                 # controls

DIGITS        <- < DIGIT+ > { fun ds -> int_of_string ds.lexeme }
DIGIT         <- [\x30-\x39]
                 # 0-9

DQUOTE        <- [\x22]
                 # " (Double Quote)

HEXDIGS       <- < HEXDIG+ > { fun h -> int_of_string ("0x" ^ h.lexeme) }
HEXDIG        <- DIGIT / "A" / "B" / "C" / "D" / "E" / "F"

HTAB          <- [\x09]
                 # horizontal tab

LF            <- [\x0A]
                 # linefeed

LWSP          <- (WSP / CRLF WSP)*
                 # Use of this linear-white-space rule
                 #  permits lines containing only white
                 #  space that are no longer legal in
                 #  mail headers and have caused
                 #  interoperability problems in other
                 #  contexts.
                 # Do not use when defining mail
                 #  headers and use with caution in
                 #  other contexts.

OCTET         <- [\x00-\xFF]
                 # 8 bits of data

SP            <- [\x20]

VCHAR         <- [\x21-\x7E]
                 # visible (printing) characters

WSP           <- SP / HTAB
                 # white space

