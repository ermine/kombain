%{

open Peg_input
open Peg_lib
open Peg_grammar
open Printf

%}

# Hierarchical syntax

Grammar		<- Spacing Declaration? Definition+ EndOfFile

Declaration  <- '%{' < ( !'%}' .)* > '%}' Spacing       { make_declaration }

Definition   <- Identifier LEFTARROW Expression { make_definition }
              / < . > { fun {start = (line, col)} ->
                          raise (Error (sprintf 
                            "Invalid rule definition at line %d col %d" 
                            line col)) 
                      }

Expression	<- Sequence (SLASH Sequence)*       { make_alternates }

Sequence	<- Item* Action?                      { make_sequence }

Item      <- Identifier AT Suffix               { make_pattern }
           / Prefix

Prefix		<- (AND                               { make_predicate_and }
             / NOT                              { make_predicate_not }
             )? Suffix                          { make_prefix }
                                                

Suffix		<- Primary ( QUESTION 		    { fun _ r -> Opt r }
			               / STAR 			      { fun _ r -> Star r }
			               / PLUS			        { fun _ r -> Plus r }
			               )?                 { fun (p, f) ->
                                            match f with
                                              | None -> p
                                              | Some f -> f p
                                        }

Primary		<- Identifier !LEFTARROW          { make_name }
		       / OPEN Expression CLOSE
           / < OPEN > { fun {start = (line, col)} ->
                   raise (Error (sprintf "Unmatched '(' at line %d col %d"
                         line col))
                 }
           / Literal 
		       / Class 
		       / DOT
		       / < LEFTANGLE > Expression (RIGHTANGLE   { fun () -> false }
                                      /             { fun () -> true })
             { fun ({start = (line, col)}, (expr, err)) ->
                if err then
                  raise (Error (sprintf "Unmatchec '<' at line %d col %d" 
                                line col))
                else
                  make_tokenizer expr
            }

# Lexical syntax

Identifier	<- < IdentStart IdentCont* > Spacing

IdentStart	<- [a-zA-Z_]
IdentCont	  <- IdentStart / [0-9']
Literal		  <- ['] (!['] Char)* ['] Spacing  { make_literal }
		         / ["] (!["] Char)* ["] Spacing  { make_literal }
Class		    <- '[' (!']' Range)* ']' Spacing   { make_class }
             / < '[' > { fun {start = (line, col)} ->
                          raise (Error (sprintf "Unmatched '[' at line %d col %d"
                                        line col)) }
Range		    <- Char '-' Char                   { fun (c1, c2) -> Range (c1, c2) }
             / Char                            { fun c -> Char c }
Char		    <- '\\' < [nrt'"\[\]\\] >          { make_escaped_char }
		         / '\\' < [0-3][0-7][0-7] >        { make_octet_char }
		         / '\\' < [0-7] [0-7]? >           { make_octet_char }
             / '\\' '-'                        { fun () -> '-' }
		         /  !'\\' < .  >                   { make_char }
LEFTARROW	  <- '<-' Spacing
SLASH		    <- '/' Spacing
AND		      <- '&' Spacing
NOT		      <- '!' Spacing
QUESTION	  <- '?' Spacing
STAR		    <- '*' Spacing
PLUS		    <- '+' Spacing
OPEN		    <- '(' Spacing
CLOSE		    <- ')' Spacing
DOT		      <- '.' Spacing                          { fun () -> Any }
Spacing		  <- (Space / Comment)*
Comment		  <- '#' (!EndOfLine .)* EndOfLine
Space		    <- ' ' / '\t' / EndOfLine
EndOfLine	  <- '\r\n' / '\r' / '\n'
EndOfFile	  <- !.

Action		  <- '{' < (Action' / !'}' .)* >  '}' Spacing
             / < '{' > { unmatch_curly_bracket }
Action'     <- '{' (Action' / !'}' .)* '}'
             / < '{' > { unmatch_curly_bracket }

LEFTANGLE	  <- '<' Spacing
RIGHTANGLE	<- '>' Spacing
AT          <- '@' Spacing