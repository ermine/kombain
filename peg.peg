%{

open Peg_input
open Peg_lib
open Peg_grammar

%}

# Hierarchical syntax

Grammar		<- Spacing Declaration? Definition+ EndOfFile

Declaration  <- '%{' < ( !'%}' .)* : make_declaration > '%}' Spacing

Definition   <- Identifier LEFTARROW Expression	
                  { fun state _ ->
                      match state with
							          | x :: Name name :: xs -> Rule (name, x) :: xs
							          | state -> List.iter print_token state; assert false
							    }
             / !EndOfFile { fun state input ->
                             Printf.printf "Invalid syntax at line %d col %d\n"
                               input.line input.col;
                             print_remaining input;
                             Pervasives.exit 1
                           }
                               

Expression	<- Sequence (SLASH Sequence		{ fun state input ->
                                              match state with
							                                  | x2 :: x1 :: xs -> 
                                                    Alternate (x1, x2) :: xs
							                                  | _ -> assert false
							                            }
				                )*

Sequence	<- Prefix (Prefix			{ fun state _ ->
                match state with
							    | x2 :: x1 :: xs -> Sequence (x1, x2) :: xs
							    | _ -> assert false
							}
			         )*

Prefix		<- AND Suffix				{ (fun state _ ->
                match state with
							    | x :: xs -> PredicateNOT (PredicateNOT x) :: xs
							    | _ -> assert false)
							}
		       / NOT Suffix				{ (fun state _ ->
                match state with
							    | x :: xs -> PredicateNOT x :: xs
							    | _ -> assert false)
							}
		       / Suffix

Suffix		<- Primary (QUESTION 			{ (fun state _ ->
                match state with
							    | x :: xs -> Alternate (x, Epsilon) :: xs
							    | _ -> assert false)
							}
			   / STAR 			{ (fun state _ ->
                match state with
							    | x :: xs -> Star x :: xs
							    | _ -> assert false)
							}
			   / PLUS			{ (fun state _ ->
                match state with
							    | x :: xs -> Sequence (x, Star x) :: xs
							    | _ -> assert false)
							}
			)?

Primary		<- Identifier '@' Spacing OPEN Expression CLOSE
                         { fun state input ->
                             match state with
                               | x :: Name name :: xs -> Pattern (name, x) :: xs
                               | _ -> assert false
                         }
           / Identifier !LEFTARROW
		        / OPEN Expression CLOSE
           / Literal 
		       / Class 
		       / DOT
		       / Action         
		       / LEFTANGLE Expression 
                       (COLON Tokenizer RIGHTANGLE 
                         { fun state _ ->
                             match state with
							 	              | Name name :: x :: xs -> Tokenizer (x, name) :: xs
							 	              | _ -> assert false
							 	        }
                       
                       / !EndOfFile 
                         { fun _ input -> 
                             Printf.printf "Invalid Syntax at line %d col %d\n" 
                               input.line input.col;
                             Pervasives.exit 1               
                         }
                       )

# Lexical syntax

Identifier	<- < IdentStart IdentCont* : make_name > Spacing

IdentStart	<- [a-zA-Z_]
IdentCont	<- IdentStart / [0-9]
Literal		<- ['] 						{ (fun state _ -> Literal [] :: state) }
		       (!['] Char				{ (fun state _ ->
                 match state with
								   | Char x :: Literal chars :: xs -> Literal (x :: chars) :: xs
								   | state -> List.iter print_token state; assert false)
								}
			)* ['] Spacing
		 / ["] 						{ (fun state _ -> Literal [] :: state) }
		       (!["] Char				{ (fun state _ ->
                match state with
								  | Char x :: Literal chars :: xs -> Literal (x :: chars) :: xs
								  | _ -> assert false)
								}
			)* ["] Spacing
Class		<- '['						{ (fun state _ -> Class [] :: state) }
		        (!']' Range				{ (fun state _ ->
                  match state with
								    | Char x2 :: Char x1 :: Class rs :: xs -> Class ([x1;x2] :: rs) :: xs
								    | Char x :: Class rs :: xs -> Class ([x] :: rs) :: xs
								    | _ -> assert false)
								}
			)* ']' Spacing
Range		     <- Char '-' Char / Char
Char		     <- '\\' < [nrt'"\[\]\\] : make_escaped_char >
		          / '\\' < [0-3][0-7][0-7] : make_octet_char >
		          / '\\' < [0-7] [0-7]? : make_octet_char >
		          /  !'\\' < . : make_any_char >
LEFTARROW	   <- '<-' Spacing
SLASH		     <- '/' Spacing
AND		       <- '&' Spacing
NOT		       <- '!' Spacing
QUESTION	   <- '?' Spacing
STAR		     <- '*' Spacing
PLUS		     <- '+' Spacing
OPEN		     <- '(' Spacing
CLOSE		     <- ')' Spacing
DOT		       <- '.' Spacing     { (fun state _ -> Any :: state) }
Spacing		   <- (Space / Comment)*
Comment		   <- '#' (!EndOfLine .)* EndOfLine
Space		     <- ' ' / '\t' / EndOfLine
EndOfLine	   <- '\r\n' / '\r' / '\n'
EndOfFile	   <- !.

Action		   <- '{' < ( !'}' .)* : make_action > '}' Spacing
Tokenizer	   <-  < IdentStart [a-zA-Z_']* : make_name > Spacing
LEFTANGLE	    <- '<' Spacing
RIGHTANGLE	  <- '>' Spacing
COLON		      <- ':' Spacing
